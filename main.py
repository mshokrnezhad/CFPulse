from utils import *
from urls import URLS
import os
from agents import agent
from pydantic_ai.providers.openrouter import OpenRouterProvider
from pydantic_ai import Agent
from pydantic_ai.models.openai import OpenAIModel
from dotenv import load_dotenv
import asyncio
import shutil

DEST_FOLDER = "downloads"

load_dotenv()

ROUTE = os.getenv("ROUTE")
API_KEY = os.getenv("API_KEY")
BASE_URL = os.getenv("BASE_URL")
PAGE_ID = os.getenv("NOTION_PAGE_ID")
NOTION_TOKEN = os.getenv("NOTION_TOKEN")
TMP_FOLDER = os.getenv("TMP_FOLDER")
KB_FILENAME = os.getenv("KB_FILENAME")
RESULTS_FILENAME = os.getenv("RESULTS_FILENAME")
KB_FILE_PATH = TMP_FOLDER + "/" + KB_FILENAME + ".txt"
RESULTS_FILE_PATH = TMP_FOLDER + "/" + RESULTS_FILENAME + ".json"
EMAIL_RECEIVER = os.getenv("EMAIL_RECEIVER")


model = OpenAIModel(ROUTE, provider=OpenRouterProvider(api_key=API_KEY))
agent = Agent(model)


def process_url(entry):
    """
    Process a single URL entry: fetch, compare, print results, and fetch linked <a> hrefs.
    Args:
        entry (dict): Contains 'name', 'base', 'url', and 'element'.
    """
    name = entry['name']
    url = entry['url']
    base = entry['base']
    element = entry.get('element')
    subfolder = os.path.join(DEST_FOLDER, name)
    filename = get_filename_from_url(url)
    new_content, file_path = download_file(url, subfolder, filename)
    if os.path.exists(file_path):
        with open(file_path, 'r', encoding='utf-8') as f:
            old_content = f.read()
        print(f"\n--- Checking: {name} ---")
        results = show_diff_and_extract_links(old_content, new_content, base, element)
        for entry in results:
            href = entry['href']
            text = entry.get('text')
            if href:
                fetch_and_store_linked_file(href, TMP_FOLDER, base, name=name, text=text)
    else:
        print(f"\n--- First time saving: {name} ---")
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)


async def main():
    print("\n" + "-" * 50)
    print("STEP 0: Finding New CFPs")
    print("-" * 50)

    # for entry in URLS:
    #     process_url(entry)

    print("\n" + "-" * 50)
    print("STEP 1: Loading KB")
    print("-" * 50)

    # if not PAGE_ID or not NOTION_TOKEN:
    #     print("Please set NOTION_PAGE_ID and NOTION_TOKEN environment variables.")
    # else:
    #     save_notion_markdown(PAGE_ID, NOTION_TOKEN, KB_FILE_PATH)

    print("\n" + "-" * 50)
    print("STEP 2: Loading CFPs")
    print("-" * 50)

    cfps = load_diff_files(TMP_FOLDER, KB_FILENAME)
    print(f"Total files processed: {len(cfps)}")

    print("\n" + "-" * 50)
    print("STEP 3: Processing CFPs with AI agent")
    print("-" * 50)

    for entry in cfps:
        if entry['venue'] != 'KB':  # Skip the KB entry itself
            kb_entry = next((item for item in cfps if item['venue'] == 'KB'), None)
            if kb_entry:
                prompt = generate_cfp_prompt(kb_entry['text'], entry['text'])

                print(f"Processing CFP: {entry['title']} ---")
                print(f"Venue: {entry['venue']}")
                print(f"Link: {entry['link']}")
                print("Prompt generated successfully.")
                entry['prompt'] = prompt

                response = await agent.run(prompt)
                # print(response.output)
                entry['response'] = response.output
                print("Response generated by AI agent.")

    save_cfps_to_json(cfps, RESULTS_FILE_PATH)

    print("\n" + "-" * 50)
    print("STEP 5: Emailing results")
    print("-" * 50)

    # Send individual emails for each CFP entry (excluding KB)
    for entry in cfps:
        if entry['venue'] != 'KB':  # Skip the KB entry
            email_body = create_email_body_for_entry(entry)

            send_email_with_attachment(
                subject=f"CFP Analysis: {entry['title']}",
                body=email_body,
                to_email=EMAIL_RECEIVER,
            )
            print(f"Email sent for: {entry['title']}")

    print("All emails sent.")

    print("\n" + "-" * 50)
    print("STEP 6: Cleaning up temporary files")
    print("-" * 50)

    try:
        # Remove all files in the temporary folder but keep the folder itself
        for filename in os.listdir(TMP_FOLDER):
            file_path = os.path.join(TMP_FOLDER, filename)
            if os.path.isfile(file_path):
                os.remove(file_path)
                print(f"Removed file: {filename}")
        print(f"Successfully cleaned temporary folder: {TMP_FOLDER}")
    except Exception as e:
        print(f"Error cleaning temporary folder: {e}")


if __name__ == "__main__":
    asyncio.run(main())
